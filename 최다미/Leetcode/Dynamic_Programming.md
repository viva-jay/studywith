# Dynamic Programming (DP, 동적계획법)

DP, 즉 동적계획법이란 복잡한 문제를 간단한 여러 개의 문제로 나누어 푸는 방법을 말한다.
이것은 부분 문제 반복과 최적 부분 구조를 가지고 있는 알고리즘을 일반적인 방법에 비해 더욱 적은 시간 내에 풀 때 사용한다.

DP가 적용되기 위해서는 아래와 같이 두 가지 조건을 만족해야 한다.
1. Overlapping Subproblems (겹치는 부분 문제) : 동일한 작은 문제들이 반복하여 나타나는 경우
2. Optimal Substructure (최적 부분 구조) : 부분 문제의 최적 결과 값을 사용해 전체 문제의 최적 결과를 낼 수 있는 경우

DP는 특정한 경우에 사용하는 알고리즘이 아니라 하나의 방법론이므로 다양한 문제 해결에 쓰일 수 있다.   
일반적으로 DP를 사용하기 전에는 아래의 과정을 거쳐 진행할 수 있다.

1. DP로 풀 수 있는 문제인지 확인하기
   
   조건이 충족되는 문제인지 한 번 체크해보는 것이 좋다.   
   보통 특정 데이터 내 최대화/최소화 계산을 하거나 특정 조건 내 데이터를 세야 한다거나 확률 등의 계산의 경우 DP로 풀 수 있는 경우가 많다.


2. 문제의 변수를 파악하기

    DP는 현재 변수에 따라 그 결과 값을 찾고 그것을 전달하여 재사용하는 것을 거친다.   
    즉, 문제 내 변수의 개수를 알아내야 한다는 것. 이것을 영어로 "state"를 결정한다고 한다.


3. 변수 간 관계식 만들기 (점화식)

   변수들에 의해 결과 값이 달라지지만 동일한 변수값인 경우 결과는 동일하다. 또한 우리는 그 결과값을 그대로 이용할 것이므로 그 관계식을 만들어낼 수 있어야 한다.   
   그러한 식을 점화식이라고 부르며 그를 통해 우리면 짧은 코드 내에서 반복/재귀를 통해 문제가 자동으로 해결되도록 구축할 수 있게 된다.   
   예를 들어 피보나치 수열에서는 f(n) = f(n-1) + f(n-2) 였다. 이는 변수의 개수, 문제의 상황마다 모두 다를 수 있다.


4. 메모하기

    변수 간 관계식까지 정상적으로 생성되었다면 변수의 값에 따른 결과를 저장해야 한다. 이것을 메모한다고 하여 Memoization이라고 부른다.   
    변수 값에 따른 결과를 저장할 배열 등을 미리 만들고 그 결과를 나올 때마다 배열 내에 저장하고 그 저장된 값을 재사용하는 방식으로 문제를 해결해 나간다.   
    이 결과 값을 저장할 때는 보통 배열을 쓰며 변수의 개수에 따라 배열의 차원이 1~3차원 등 다양할 수 있다.


5. 기저 상태 파악하기

    여기까지 진행했으면, 가장 작은 문제의 상태를 알아야 한다. 보통 몇 가지 예시를 직접 손으로 테스트하여 구성하는 경우가 많다.   
    피보나치 수열을 예시로 들면, f(0) = 0, f(1) = 1과 같은 방식이다. 이후 두 가지 숫자를 더해가며 값을 구하지만 가장 작은 문제는 저 2개로 볼 수 있다.   
    해당 기저 문제에 대해 파악 후 미리 배열 등에 저장해두면 된다. 이 경우, 피보나치 수열은 매우 간단했지만 문제에 따라 좀 복잡할 수 있다.


6. 구현하기

   DP는 2가지 방식으로 구현할 수 있다.
   1) Bottom-Up (Tabulation 방식) - 반복문 사용. 아래에서 부터 계산을 수행 하고 누적시켜서 전체 큰 문제를 해결하는 방식
   2) Top-Down (Memoization 방식) - 재귀 사용. dp[0]의 기저 상태에서 출발하는 대신 dp[n]의 값을 찾기 위해 위에서 부터 바로 호출을 시작하여 dp[0]의 상태까지 내려간 다음 해당 결과 값을 재귀를 통해 전이시켜 재활용하는 방식

## 비트 계산 문제
### 문제 : [Counting Bits](https://leetcode.com/problems/counting-bits/)
**Bottom-Up 방식을 이용한 문제 풀이**
- 시간 복잡도 : n개의 요소에 대해 O(1) 의 탐색을 하므로 시간 복잡도는 O(n) 이다.
- 공간 복잡도 : n+1개의 배열이 필요하므로, 공간 복잡도는 O(n+1) 이다.
- 풀이
    ```java
    class Solution {
        public int[] countBits(int n) {
            int[] ans = new int[n + 1];
            for (int i = 1; i <= n; i++) {
                ans[i] = ans[i >> 1] + (i & 1);
            }
            return ans;
        }
    }
    ```